#version 330 core

//Input Data
in vec4 gl_FragCoord;
uniform mat4 ViewMat;

//Ouput data
out vec3 fragColor;


// ray marching
const int max_iterations = 256;
const float stop_threshold = 0.001;
const float grad_step = 0.02;
const float clip_far = 1000.0;

// math
const float PI = 3.14159265359;
const float DEG_TO_RAD = PI / 180.0;

// iq's distance function
float sdSphere(vec3 pos, float r)
{
	return length(pos) - r;
}

float sdBox(vec3 p, vec3 b)
{
  vec3 d = abs(p) - b;
  return min(max(d.x,max(d.y,d.z)),0.0) + length(max(d,0.0));
}


float sdUnion(float d0, float d1)
{
	return min(d0, d1);
}

float sdInter(float d0, float d1)
{
	return max(d0, d1);
}

float sdSub(float d0, float d1)
{
	return max(d0, -d1);
}

float sdUnion_s(float a, float b, float k)
{
	float h = clamp(0.5+0.5*(b-a)/k, 0.0, 1.0);
	return mix(b, a, h) - k*h*(1.0-h);
}

float sfDisp(vec3 p)
{
	return sin(p.x)*sin(p.y)*sin(p.z);
}

vec3 sdTwist(vec3 p, float a)
{
	float c = cos(a*p.y);
	float s = sin(a*p.y);
	mat2  m = mat2(c,-s,s,c);
	return vec3(m*p.xz,p.y);
}

vec3 sdRep(vec3 p, vec3 c)
{
	return mod(p,c)-0.5*c;
}

// get distance in the world
float dist_field(vec3 p)
{
	//  p = sdRep( p, vec3( 4.0 ) );
	//  p = sdTwist( p, 3.0 );
	
	float d0 = sdBox(p, vec3(0.5));
	float d1 = sdSphere(p, 0.6);
	
	float d = sdInter(d1, d0) + sin(p.y*2*PI*10.0f)/100.0f + sin(p.x*2*PI*10.0f)/500.0f + sin(p.z*2*PI*10.0f)/500.0f;

	return d;
	//return d + sfDisp( p * 2.5 );
	//return sdUnion_s( d + sfDisp( p * 2.5 * sin( iTime * 1.01 ) ), d1, 0.1 );
}

// get ray direction
vec3 ray_dir(float fov, vec2 size, vec2 pos) 
{
	vec2 xy = pos - size * 0.5;

	float cot_half_fov = tan( (90.0 - fov*0.5) * DEG_TO_RAD );	
	float z = (size.x * 0.5) * cot_half_fov;
	
	return normalize(vec3(xy, -z));
}

// ray marching
bool ray_marching(vec3 dir, inout float depth)
{
	float t = 0.0;
	float d = 10000.0;
	float dt = 0.0;
	for (int i=0; i<max_iterations; i++) 
	{
		// vec3 v = eye + dir * t;
		vec3 v = (ViewMat * vec4(dir*t,1)).xyz;
		d = dist_field(v);
		if (d < 0.001)
		{
			break;
		}
		dt = min(abs(d), 0.1);
		t += dt;
		
		if (t > depth)
		{
			break;
		}
	}
	
	if (d >= 0.001)
	{
		return false;
	}
	
	t -= dt;
	for (int i = 0; i < max_iterations/16; i++)
	{
		dt *= 0.5;
		
		// vec3 v = eye + dir * (t + dt);
		vec3 v = (ViewMat * vec4(dir*(t+dt),1)).xyz;
		if (dist_field(v) >= 0.001)
		{
			t += dt;
		}
	}
	
	depth = t;
	return true;
}

// camera rotation : pitch, yaw
mat3 rotationXY(vec2 angle)
{
	vec2 c = cos(angle);
	vec2 s = sin(angle);
	
	return mat3(
		c.y      ,  0.0, -s.y,
		s.y * s.x,  c.x,  c.y * s.x,
		s.y * c.x, -s.x,  c.y * c.x
	);
}

void main()
{
	vec2 iResolution = vec2(1024, 768);

	// default ray dir
	vec3 dir = ray_dir(45.0, iResolution.xy, gl_FragCoord.xy );

	// ray marching
	float depth = clip_far;
	vec3 n = vec3( 0.0 );

	if (!ray_marching(dir, depth)) 
	{
		fragColor = vec3(0);
		return;
	}

	fragColor = vec3(1/(depth));
}